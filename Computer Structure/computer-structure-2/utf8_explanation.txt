212945760 Ori Dabush

הקידוד UTF-8 הוא אחת מהשיטות הנפוצות ביותר לקידוד תווי ה-unicode (ה-unicode הוא מיפוי של כל תו למספר ייחודי). הקידוד UTF-8 שומר כל תו בבייט אחד עד ארבעה בתים, לפי התדירות בו משתמשים בתו (כלומר תו נפוץ יותר יהיה שמור בפחות בתים).
לקידוד ה-UTF-8 יתרונות רבים, ביניהם תאימות לאחור ל-ASCII, חיסכון בזיכרון ועמידות לאיבוד או השחתת מידע (ארחיב על כל אלו ועל יתרונות נוספים בהמשך הסיכום).

*הערה - כאשר אכתוב בסיכום מספר (לדוגמא 0x007F) הכוונה היא למספר עצמו ולא לתו שזהו ערכו. כשאתכוון לתו אציין זאת.

קידוד תווים ב-UTF-8 נעשה באופן הבא:
*אם ערך התו הוא בטווח שבין 0x0000 לבין 0x007F (אלו הם תווי ה-ASCII שערכם נע בין 0 ל-127), התו מומר פשוט למספר המתאים לו וב-MSB מושם הערך 0 (כלומר המספר של התו תופס 7 ביטים והביט השמיני שהוא ה-MSB יהיה 0). בעזרת צורת שמירת המידע הנ"ל מושגת תאימות לאחור ל-ASCII, שכן אם ניקח קובץ שנכתב ב-ASCII וננסה לפענח אותו לפי UTF-8 נקבל את מה שרצינו.
*אם ערך התו גדול מ-0x007F, נקודד את התו באמצעות מספר בתים (2-4 בתים). הבית הראשון יכיל 1 כמספר הבתים שישמרו עבור התו הנוכחי ולאחר ה-1ים יופיע 0, וכל בית אחר של התו יתחיל ב-10 (לדוגמא אם עבור תו מסוים ישמרו 4 בתים אז הבית הראשון שלו יראה כך 11110xxx ושאר הבתים יראו כך 10xxxxxx). בשאר הערכים של הבתים הללו יופיע המספר שמייצג את התו. כפי שניתן לשים לב לא משתמשים בכל ה-32 ביטים על מנת לייצג את המספר עצמו אלא במקסימום 21 ביטים אך אלו מספיק ביטים בכדי לייצג את תווי ה-unicode. נשים לב לטווחים השונים של המספרים:
תווים שמספרם בטווח 0x000080 עד 0x0007FF יקודדו באמצעות 2 בתים.
תווים שמספרם בטווח 0x000800 עד 0x00FFFF יקודדו באמצעות 3 בתים.
תווים שמספרם בטווח 0x010000 עד 0x1FFFFF יקודדו באמצעות 4 בתים.

ניתן דוגמא לקידוד של התו 'א' שמספרו הוא 0x05D0:
ראשית, 0x05D0 נמצא בטווח 0x000080 עד 0x0007FF ולכן יקודד על ידי שתי בתים שבצורה כללית יראו כך - 110xxxxx 10xxxxxx.
כעת, הייצוג הבינארי של 0x05D0 הוא 0b10111010000, ולכן כשנציב את המספר ב-"תבנית" של הבתים שלו נקבל - 11010111-10010000. הבית השמאלי מתחיל ב-110 כיוון שעבור התו הנוכחי נקודד 2 בתים, והבית הימני מתחיל ב-10 כיוון שהוא בית נוסף עבור התו הזה.

כדי לפענח קובץ שקודד ב-UTF-8 נסתכל בכל פעם על הבית הנוכחי ונשים לב לפי ההתחלה שלו כמה בתים הוקצו עבור התו הנוכחי (אם ה-MSB שלו 0 זה תו ASCII שהוקצה עבורו בית אחד, אחרת נסתכל בכמה 1ים הוא מתחיל לפני ה-0 הראשון). לאחר מכן נפענח את המספר לאחר הסרת התחיליות שהקידוד מוסיף (ה-1ים בבית הראשון כמספר הבתים שהוקצו עבור התו הנוכחי וה-10 בתחילת כל בית אחר).

הקידוד UTF-8 הוא קידוד הגיוני, הוא עוצב כך שלא ניתן לכתוב כמה רצפים של תווים על ידי אותו קידוד וכך לא ניתן לפענח את הקידוד בכמה דרכים שונות. בנוסף הקידוד עמיד מאוד בפני איבוד או השחתת מידע בכך שאם תו אחד נפגע זה לא מפריע לשאר התווים בקובץ, כיוון שכל תו עומד בפני עצמו וגם אם תו מסוים לא מקודד נכון פשוט ניתן לעבור לתו הבא (על ידי חיפוש התחילית הבאה של תו שהיא MSB שהוא 0 או 1ים כמספר הבתים ואז 0). בנוסף על ידי העובדה שלתווי ה-ASCII קבעו שה-MSB יהיה 0 אי אפשר להתבלבל בין תו שקודד בבית אחד לבין תווים אחרים ובתים של תווים אחרים. יתרון נוסף של צורת הקידוד היא שבעזרת העובדה שכל תו הוא "עצמאי" היא שניתן להפעניל אלגוריתמי חיפוש שונים בשביל למצוא מידע בקובץ.

נשים לב שב-UTF-8 יש תווים שניתן לשמור בכמה צורות (כלומר במספר קידודים שונים) שכולם יהיו זהות. ניתן לדוגמא את התו שמספרו 0x000A (שהוא תו line feed). מצד אחד התו הוא תו ASCII ולכן ניתן לקודד אותו בבית אחד שיהיה פשוט הייצוג הבינארי של 0x000A (כלומר 00001010). מצד שני אם נקודד את התו באחת מהדרכים הבאות - 0xC08A, 0xE0808A, 0xF0808A נקבל את אותה התוצאה לאחר פענוח הקידוד. אלו הם ייצוגים של בתים שבבית הראשון יש 1ים לפי מספר הבתים שיש ולאחר מכן 0ים, ובכל אחד מהבתים פרט לאחרון יש 10000000 (כלומר 10 של הקידוד והשאר 0ים) ובבית האחרון מופיע התו עצמו (כלומר 10001010 - 10 של הקידוד ו-001010 של התו) וכך לאחר פיענוח כל אחת מהצורות הנ"ל נקבל את המספר 0x000A שיניב את אותו התו (line feed).
בעיה זו נקראת בעית הצורות הארוכות ובעבר נעשה בה שימוש זדוני של הצגת תווים בצורתן הארוכה בכדי לעקוף מנגנוני אבטחה שונים שלא פענחו את הקוד אלא ביצעו את הבדיקות על הקידוד עצמו וכך לא בדקו תווים שמיוצגים בצורתם הארוכה.
